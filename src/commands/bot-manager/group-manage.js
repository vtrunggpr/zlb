import { MessageType } from "zlbotdqt";
import * as cv from "../../utils/canvas/index.js";
import { getUserInfoData } from "../../service-hahuyhoang/info-service/user-info.js";
import { sendMessageWarning } from "../../service-hahuyhoang/chat-zalo/chat-style/chat-style.js";
import {
  writeCommandConfig,
  writeGroupSettings,
} from "../../utils/io-json.js";
import {
  sendMessageFromSQL,
  sendMessageInsufficientAuthority,
  sendMessageStateQuote,
} from "../../service-hahuyhoang/chat-zalo/chat-style/chat-style.js";
import { getGlobalPrefix } from "../../service-hahuyhoang/service.js";
import { getCommandConfig, isAdmin } from "../../index.js";
import { removeMention } from "../../utils/format-util.js";
import { managerData } from "./active-bot.js";

export async function handleKick(api, message, groupInfo, groupSettings) {
  const threadId = message.threadId;
  const groupName = groupInfo.name;
  const senderName = message.data.dName;

  if (!message.data.mentions || message.data.mentions.length === 0) {
    await sendMessageWarning(
      api,
      message,
      ":D S·∫øp mu·ªën kick ai? üöÄ",
      false
    );
    return;
  }

  const uids = [];
  const UserDataMentions = [];
  for (const mention of message.data.mentions) {
    if (isAdmin(mention.uid, threadId)) {
      await sendMessageWarning(
        api,
        message,
        "S·∫øp kh√¥ng th·ªÉ b·∫£o em kick qu·∫£n tr·ªã bot ƒë∆∞·ª£c üöÄ",
        false
      );
      continue;
    }
    uids.push(mention.uid);
    try {
      const userInfo = await getUserInfoData(api, mention.uid);
      if (userInfo) {
        UserDataMentions.push(userInfo);
      }
    } catch (error) {
      console.error(
        `Kh√¥ng th·ªÉ l·∫•y th√¥ng tin cho ng∆∞·ªùi d√πng ${mention.uid}:`,
        error
      );
    }
  }

  if (uids.length === 0) {
    return;
  }

  try {
    const result = await api.removeUserFromGroup(threadId, uids);
    if (result.errorMembers.length > 0) {
      await sendMessageWarning(
        api,
        message,
        "ƒê∆∞a Em Key V√†ng üîë, Em Kick Cho S·∫øp Xem :D üöÄ",
        false
      );
      return;
    }

    for (const userInfo of UserDataMentions) {
      let imagePath = null;
      try {
        if (groupSettings?.[threadId]?.enableKickImage === true) {
          imagePath = await cv.createKickImage(
            userInfo,
            groupInfo.name,
            groupInfo.type,
            userInfo.genderId,
            senderName
          );
    
          const kickMessage = {
            msg: "",
            attachments: [imagePath],
          };
    
          await api.sendMessage(kickMessage, threadId, MessageType.GroupMessage);
        }
      } catch (error) {
        console.error("L·ªói khi t·∫°o v√† g·ª≠i ·∫£nh k·∫øt qu·∫£:", error);
      } finally {
        await cv.clearImagePath(imagePath);
      }
    }
  } catch (error) {
    console.error("Ch·∫Øc Ch·∫Øn L√† ƒê√£ C√≥ L·ªói G√¨ ƒê√≥ :D", error);
    await sendMessageWarning(
      api,
      message,
      "ƒê∆∞a Em Key V√†ng üîë, Em Kick Cho S·∫øp Xem :D üöÄ",
      false
    );
  }
}

export async function handleBlock(api, message, groupInfo, groupSettings) {
  const threadId = message.threadId;
  const senderName = message.data.dName;

  if (!message.data.mentions || message.data.mentions.length === 0) {
    await sendMessageWarning(api, message, ":D S·∫øp mu·ªën ch·∫∑n ai? üöÄ", false);
    return;
  }

  const uids = [];
  const UserDataMentions = [];
  for (const mention of message.data.mentions) {
    if (isAdmin(mention.uid, threadId)) {
      await sendMessageWarning(api, message, "S·∫øp kh√¥ng th·ªÉ b·∫£o em block qu·∫£n tr·ªã bot ƒë∆∞·ª£c üöÄ", false);
      continue;
    }
    uids.push(mention.uid);
    try {
      const userInfo = await getUserInfoData(api, mention.uid);
      if (userInfo) {
        UserDataMentions.push(userInfo);
      }
    } catch (error) {
      console.error(`Kh√¥ng th·ªÉ l·∫•y th√¥ng tin cho ng∆∞·ªùi d√πng ${mention.uid}:`, error);
    }
  }

  if (uids.length === 0) {
    return;
  }

  try {
    const result = await api.blockUsers(threadId, uids);
    if (result.errorMembers && result.errorMembers.length > 0) {
      await sendMessageWarning(api, message, "ƒê∆∞a Em Key V√†ng üîë, Em Block Cho S·∫øp Xem :D üöÄ", false);
      return;
    }

    if (groupSettings?.[threadId]?.enableBlockImage === true) {
      for (const userInfo of UserDataMentions) {
        let imagePath = null;
        try {
          imagePath = await cv.createBlockImage(
            userInfo,
            groupInfo.name,
            groupInfo.type,
            userInfo.genderId,
            senderName
          );

          const blockMessage = {
            msg: "",
            attachments: [imagePath],
          };

          await api.sendMessage(blockMessage, threadId, message.type);
        } catch (error) {
          console.error("L·ªói khi t·∫°o v√† g·ª≠i ·∫£nh block:", error);
        } finally {
          await cv.clearImagePath(imagePath);
        }
      }
    }
  } catch (error) {
    console.error("Ch·∫Øc Ch·∫Øn L√† ƒê√£ C√≥ L·ªói G√¨ ƒê√≥ :D", error);
    await sendMessageWarning(api, message, "ƒê∆∞a Em Key V√†ng üîë, Em Block Cho S·∫øp Xem :D üöÄ", false);
  }
}
export async function handleKeyCommands(api, message, groupSettings, isAdminLevelHighest) {
  const content = removeMention(message);
  const senderId = message.data.uidFrom;
  const threadId = message.threadId;
  const prefix = getGlobalPrefix();

  if (!content.startsWith(`${prefix}keygold`) && !content.startsWith(`${prefix}keysilver`) && !content.startsWith(`${prefix}unkey`)) {
    return false;
  }

  const action = content.startsWith(`${prefix}keygold`) ? "gold" : content.startsWith(`${prefix}keysilver`) ? "silver" : "unkey";

  if (!isAdminLevelHighest) {
    const caption = "Ch·ªâ c√≥ qu·∫£n tr·ªã bot c·∫•p cao m·ªõi ƒë∆∞·ª£c s·ª≠ d·ª•ng l·ªánh n√†y!";
    await sendMessageInsufficientAuthority(api, message, caption);
    return false;
  }

  const mentions = message.data.mentions;

  if (!mentions || mentions.length === 0) {
    await handleKeyAction(api, message, groupSettings, threadId, senderId, action, "B·∫°n");
  } else {
    for (const mention of mentions) {
      const targetId = mention.uid;
      const targetName = message.data.content.substring(mention.pos, mention.pos + mention.len).replace("@", "");
      await handleKeyAction(api, message, groupSettings, threadId, targetId, action, targetName);
    }
  }

  writeGroupSettings(groupSettings);
  return true;
}

async function handleKeyAction(api, message, groupSettings, threadId, targetId, action, targetName) {
  switch (action) {
    case "gold":
      try {
        await api.changeGroupOwner(threadId, targetId);
        await sendMessageStateQuote(api, message, `ƒê√£ nh∆∞·ªùng key v√†ng cho ${targetName}.`, true, 300000);
      } catch (error) {
        await sendMessageStateQuote(api, message, `Kh√¥ng ƒë·ªß quy·ªÅn h·∫°n ƒë·ªÉ nh∆∞·ªùng key cho ${targetName}.`, false, 300000);
      }
      break;
    case "silver":
      try {
        await api.addGroupAdmins(threadId, targetId);
        await sendMessageStateQuote(api, message, `ƒê√£ phong key b·∫°c cho ${targetName}.`, true, 300000);
      } catch (error) {
        await sendMessageStateQuote(api, message, `Kh√¥ng ƒë·ªß quy·ªÅn h·∫°n ƒë·ªÉ phong key b·∫°c cho ${targetName}.`, false, 300000);
      }
      break;
    case "unkey":
      try {
        await api.removeGroupAdmins(threadId, targetId);
        await sendMessageStateQuote(api, message, `ƒê√£ x√≥a key c·ªßa ${targetName}.`, true, 300000);
      } catch (error) {
        await sendMessageStateQuote(api, message, `${targetName} kh√¥ng c√≥ key ƒë·ªÉ x√≥a.`, false, 300000);
      }
      break;
  }
}

/*
export async function handleBlock(api, message, groupInfo, groupSettings, aliasCommand) {
  console.log("üöÄ [handleBlock] B·∫Øt ƒë·∫ßu x·ª≠ l√Ω l·ªánh");

  const prefix = getGlobalPrefix();
  const threadId = message.threadId;
  const senderName = message.data.dName;
  const senderId = message.data.uidFrom;

  const rawContent = message.data?.content || "";
  const content = rawContent.replace(`${prefix}${aliasCommand}`, "").trim();
  const args = content.split(/\s+/);
  const command = args[0]?.toLowerCase();

  console.log("üì• Raw Content:", JSON.stringify(rawContent));
  console.log("üì§ Sau khi t√°ch l·ªánh:", JSON.stringify(content));
  console.log("üß© Command:", command);

  let uids = [];
  let UserDataMentions = [];

  const botId = message.botID || global.botID || null;

  if (command === "all") {
    console.log("‚úÖ Nh·∫≠n di·ªán block all");

    let gridData = groupInfo?.gridInfoMap?.[threadId]?.memVerList;

    if (!Array.isArray(gridData)) {
      console.log("üîÑ groupInfo kh√¥ng ƒë·∫ßy ƒë·ªß, ƒëang g·ªçi api.getGroupInfo(threadId)");
      try {
        const fetchedGroupInfo = await api.getGroupInfo(threadId);
        gridData = fetchedGroupInfo?.gridInfoMap?.[threadId]?.memVerList;
      } catch (err) {
        console.error("‚ùå L·ªói khi g·ªçi api.getGroupInfo:", err);
        return;
      }
    }

    if (!Array.isArray(gridData)) {
      console.warn("‚ùå Kh√¥ng t√¨m th·∫•y danh s√°ch th√†nh vi√™n trong nh√≥m.");
      return;
    }

    const memberIds = gridData.map(id => id.split("_")[0]);

    for (const memberId of memberIds) {
      if (botId && memberId === botId) continue;
      if (await isAdmin(memberId, threadId)) continue;

      uids.push(memberId);
      try {
        const userInfo = await getUserInfoData(api, memberId);
        if (userInfo) UserDataMentions.push(userInfo);
      } catch (err) {
        console.error(`‚ö†Ô∏è Kh√¥ng th·ªÉ l·∫•y th√¥ng tin ${memberId}:`, err);
      }
    }

    console.log(`üéØ T·ªïng s·ªë UID s·∫Ω b·ªã block: ${uids.length}`);
    if (uids.length === 0) {
      console.log("‚ö†Ô∏è Kh√¥ng c√≥ ai ƒë·ªÉ block.");
      return;
    }
  } else {
    console.log("üßæ X·ª≠ l√Ω block theo mention");

    if (!message.data.mentions || message.data.mentions.length === 0) {
      await sendMessageWarning(api, message, ":D S·∫øp mu·ªën ch·∫∑n ai? üöÄ", false);
      return;
    }

    for (const mention of message.data.mentions) {
      if (await isAdmin(mention.uid, threadId)) {
        await sendMessageWarning(api, message, "S·∫øp kh√¥ng th·ªÉ b·∫£o em block qu·∫£n tr·ªã bot ƒë∆∞·ª£c üöÄ", false);
        continue;
      }
      uids.push(mention.uid);
      try {
        const userInfo = await getUserInfoData(api, mention.uid);
        if (userInfo) UserDataMentions.push(userInfo);
      } catch (err) {
        console.error(`‚ö†Ô∏è Kh√¥ng th·ªÉ l·∫•y th√¥ng tin ${mention.uid}:`, err);
      }
    }

    if (uids.length === 0) return;
  }

  try {
    console.log("üîí ƒêang g·ªçi api.blockUsers:", uids);
    const result = await api.blockUsers(threadId, uids);
    if (result?.errorMembers?.length > 0) {
      console.warn("‚ùó Kh√¥ng th·ªÉ block m·ªôt s·ªë UID:", result.errorMembers);
      if (command !== "all") {
        await sendMessageWarning(api, message, "ƒê∆∞a Em Key V√†ng üîë, Em Block Cho S·∫øp Xem :D üöÄ", false);
      }
      return;
    }

    if (groupSettings?.[threadId]?.enableBlockImage === true) {
      for (const userInfo of UserDataMentions) {
        let imagePath = null;
        try {
          imagePath = await cv.createBlockImage(
            userInfo,
            groupInfo.name,
            groupInfo.type,
            userInfo.genderId,
            senderName
          );

          await api.sendMessage(
            { msg: "", attachments: [imagePath] },
            threadId,
            message.type
          );
        } catch (err) {
          console.error("‚ùå L·ªói khi t·∫°o/g·ª≠i ·∫£nh block:", err);
        } finally {
          await cv.clearImagePath(imagePath);
        }
      }
    }
  } catch (err) {
    console.error("‚ùå L·ªói khi g·ªçi api.blockUsers:", err);
    if (command !== "all") {
      await sendMessageWarning(api, message, "ƒê∆∞a Em Key V√†ng üîë, Em Block Cho S·∫øp Xem :D üöÄ", false);
    }
  }
}
*/
export async function handleBlockBot(api, message, groupSettings) {
  const threadId = message.threadId;
  let listIdBlock = [];
  let messageContent = "";

  if (groupSettings) {
    const mentions = message.data.mentions;
    if (mentions && mentions.length > 0) {
      for (const mention of mentions) {
        const targetId = mention.uid;
        const targetName = message.data.content.substring(mention.pos, mention.pos + mention.len).replace("@", "");
        if (!isAdmin(targetId)) {
          listIdBlock.push({ targetId, targetName });
        } else {
          messageContent += `üö® Kh√¥ng th·ªÉ block bot Qu·∫£n Tr·ªã C·∫•p Cao: ${targetName}\n`;
        }
      }
    }
  } else {
    const userInfo = await getUserInfoData(api, threadId);
    if (!isAdmin(threadId)) {
      listIdBlock.push({ targetId: threadId, targetName: userInfo.name });
    } else {
      messageContent += `üö® Kh√¥ng th·ªÉ block bot Qu·∫£n Tr·ªã C·∫•p Cao: ${userInfo.name}\n`;
    }
  }

  if (listIdBlock.length > 0) {
    const blockData = managerData.data;
    let blockedUsers = [];
    let alreadyBlockedUsers = [];

    if (!Array.isArray(blockData.blockBot)) {
      blockData.blockBot = [];
    }

    for (const item of listIdBlock) {
      const isBlocked = blockData.blockBot.some((blocked) => blocked.idUserZalo === item.targetId);

      if (isBlocked) {
        alreadyBlockedUsers.push(item.targetName);
      } else {
        blockData.blockBot.push({
          idUserZalo: item.targetId,
          senderName: item.targetName,
        });
        blockedUsers.push(item.targetName);
      }
    }
    if (blockedUsers.length > 0) {
      messageContent += `‚úÖ ƒê√£ ch·∫∑n t∆∞∆°ng t√°c bot ƒë·ªëi v·ªõi: ${blockedUsers.join(", ")}\n`;
    }
    if (alreadyBlockedUsers.length > 0) {
      messageContent += `‚ùå Nh·ªØng ng∆∞·ªùi ƒë√£ b·ªã ch·∫∑n t·ª´ tr∆∞·ªõc: ${alreadyBlockedUsers.join(", ")}`;
    }

    if (messageContent.trim() === "") {
      messageContent = "üö® Kh√¥ng c√≥ m·ª•c ti√™u ƒë·ªÉ ch·∫∑n, vui l√≤ng ƒë·ªÅ c·∫≠p th√¥ng qua @mention";
    }

    await api.sendMessage(
      {
        msg: messageContent.trim(),
        quote: message,
        ttl: 300000,
      },
      message.threadId,
      message.type
    );

    managerData.hasChanges = true;
  }
}

export async function handleUnblockBot(api, message, groupSettings) {
  const threadId = message.threadId;
  let listIdUnblock = [];

  if (groupSettings) {
    const mentions = message.data.mentions;
    if (mentions && mentions.length > 0) {
      for (const mention of mentions) {
        const targetId = mention.uid;
        const targetName = message.data.content.substring(mention.pos, mention.pos + mention.len).replace("@", "");
        listIdUnblock.push({ targetId, targetName });
      }
    }
  } else {
    const userInfo = await getUserInfoData(api, threadId);
    listIdUnblock.push({ targetId: threadId, targetName: userInfo.name });
  }

  if (listIdUnblock.length > 0) {
    const blockData = managerData.data;
    let unblockUsers = [];
    let notBlockedUsers = [];

    for (const item of listIdUnblock) {
      const blockedUserIndex = blockData.blockBot.findIndex((blocked) => blocked.idUserZalo === item.targetId);

      if (blockedUserIndex !== -1) {
        blockData.blockBot.splice(blockedUserIndex, 1);
        unblockUsers.push(item.targetName);
      } else {
        notBlockedUsers.push(item.targetName);
      }
    }

    let messageContent = "";
    if (unblockUsers.length > 0) {
      messageContent += `‚úÖ ƒê√£ b·ªè ch·∫∑n t∆∞∆°ng t√°c bot ƒë·ªëi v·ªõi: ${unblockUsers.join(", ")}\n`;
    }
    if (notBlockedUsers.length > 0) {
      messageContent += `‚ùå C√°c th√†nh vi√™n sau kh√¥ng b·ªã ch·∫∑n: ${notBlockedUsers.join(", ")}`;
    }

    if (messageContent.trim() === "") {
      messageContent = "üö® Kh√¥ng c√≥ m·ª•c ti√™u ƒë·ªÉ b·ªè ch·∫∑n, vui l√≤ng ƒë·ªÅ c·∫≠p th√¥ng qua @mention";
    }

    await api.sendMessage(
      {
        msg: messageContent.trim(),
        quote: message,
        ttl: 300000,
      },
      message.threadId,
      message.type
    );

    managerData.hasChanges = true;
  }
}

export async function handleListBlockBot(api, message) {
  const blockData = managerData.data;
  const listBlockedUsers = blockData.blockBot.map((blocked) => blocked.senderName);
  if (listBlockedUsers.length === 0) {
    await api.sendMessage({ msg: `üö® Kh√¥ng c√≥ ai b·ªã ch·∫∑n t∆∞∆°ng t√°c v·ªõi bot`, ttl: 300000 }, message.threadId, message.type);
  } else {
    await api.sendMessage(
      {
        msg: `Danh s√°ch ng∆∞·ªùi d√πng ƒë√£ b·ªã ch·∫∑n t∆∞∆°ng t√°c v·ªõi bot:\n${listBlockedUsers
          .map((user, index) => `- ${index + 1}. ${user}`)
          .join("\n")}`,
        ttl: 300000,
      },
      message.threadId,
      message.type
    );
  }
}

export function isUserBlocked(senderId) {
  try {
    const blockData = managerData.data;
    if (!blockData || !blockData.blockBot) {
      return false;
    }

    return blockData.blockBot.some((blocked) => blocked.idUserZalo === senderId);
  } catch (error) {
    console.error("L·ªói khi ki·ªÉm tra tr·∫°ng th√°i block:", error);
    return false;
  }
}

export async function handleSettingGroupCommand(api, message, groupInfo, aliasCommand) {
  const content = removeMention(message);
  const threadId = message.threadId;
  const prefix = getGlobalPrefix();
  const args = content.slice(prefix.length).trim().split(/\s+/);

  args.shift();

  if (args.length < 1) {
    const result = {
      success: false,
      message: `S·ª≠ d·ª•ng: ${prefix}${aliasCommand} <lo·∫°i config> <gi√° tr·ªã>` +
        `\n\n[C√†i ƒë·∫∑t B·∫≠t/T·∫Øt] (on/off ho·∫∑c 1/0):` +
        `\n- lockchat: ${groupInfo.setting?.lockSendMsg ? "T·∫Øt" : "M·ªü"} chat trong nh√≥m` +
        `\n- lockview: ${groupInfo.setting?.lockViewMember ? "T·∫Øt" : "M·ªü"} xem th√†nh vi√™n trong nh√≥m` +
        `\n- history: ${groupInfo.setting?.enableMsgHistory ? "M·ªü" : "T·∫Øt"} cho ph√©p th√†nh vi√™n m·ªõi ƒë·ªçc tin nh·∫Øn g·∫ßn nh·∫•t` +
        `\n- joinappr: ${groupInfo.setting?.joinAppr ? "M·ªü" : "T·∫Øt"} ch·∫ø ƒë·ªô ph√™ duy·ªát th√†nh vi√™n` +
        `\n- showkey: ${groupInfo.setting?.signAdminMsg ? "M·ªü" : "T·∫Øt"} hi·ªÉn th·ªã key qu·∫£n tr·ªã` +
        `\n\n[C√†i ƒë·∫∑t Chu·ªói]:` +
        `\n- name <t√™n m·ªõi>: ƒê·ªïi t√™n nh√≥m`
    };
    await sendMessageFromSQL(api, message, result, false, 60000);
    return;
  }

  const settingType = args[0].toLowerCase();
  const value = args.slice(1).join(" ");

  // X·ª≠ l√Ω c√°c c√†i ƒë·∫∑t chu·ªói
  if (["name"].includes(settingType)) {
    if (!value) {
      await sendMessageStateQuote(api, message, `Vui l√≤ng nh·∫≠p gi√° tr·ªã cho c√†i ƒë·∫∑t ${settingType}`, false, 60000);
      return;
    }

    try {
      switch (settingType) {
        case "name":
          await api.changeGroupName(threadId, value);
          await sendMessageStateQuote(api, message, `ƒê√£ ƒë·ªïi t√™n nh√≥m th√†nh: ${value}`, true, 60000);
          break;
      }
      return;
    } catch (error) {
      console.error(`L·ªói khi thay ƒë·ªïi ${settingType}:`, error);
      await sendMessageStateQuote(api, message, `Kh√¥ng th·ªÉ thay ƒë·ªïi ${settingType}: ${error.message}`, false, 60000);
      return;
    }
  }

  // X·ª≠ l√Ω c√°c c√†i ƒë·∫∑t on/off
  if (!value || !["on", "off", "0", "1"].includes(value.toLowerCase())) {
    await sendMessageStateQuote(api, message, `Vui l√≤ng ch·ªçn on/off ho·∫∑c 1/0 ƒë·ªÉ thay ƒë·ªïi c√†i ƒë·∫∑t`, false, 60000);
    return;
  }

  const newValue = ["on", "1"].includes(value.toLowerCase()) ? 1 : 0;
  const currentSettings = groupInfo.setting || {};

  try {
    switch (settingType) {
      case "lockchat":
        currentSettings.lockSendMsg = newValue;
        const status = newValue === 1 ? "t·∫Øt" : "m·ªü";
        await updateGroupSetting(api, message, threadId, currentSettings, `ƒê√£ ${status} chat cho t·∫•t c·∫£ th√†nh vi√™n!`);
        break;

      case "lockview":
        currentSettings.lockViewMember = newValue;
        const memberStatus = newValue === 1 ? "t·∫Øt" : "m·ªü";
        await updateGroupSetting(api, message, threadId, currentSettings, `ƒê√£ ${memberStatus} xem th√†nh vi√™n trong nh√≥m!`);
        break;

      case "history":
        currentSettings.enableMsgHistory = newValue;
        const historyStatus = newValue === 1 ? "m·ªü" : "t·∫Øt";
        await updateGroupSetting(api, message, threadId, currentSettings, `ƒê√£ ${historyStatus} cho ph√©p th√†nh vi√™n m·ªõi ƒë·ªçc tin nh·∫Øn g·∫ßn nh·∫•t!`);
        break;

      case "joinappr":
        currentSettings.joinAppr = newValue;
        const joinApprStatus = newValue === 1 ? "m·ªü" : "t·∫Øt";
        await updateGroupSetting(api, message, threadId, currentSettings, `ƒê√£ ${joinApprStatus} ch·∫ø ƒë·ªô ph√™ duy·ªát th√†nh vi√™n!`);
        break;

      case "showkey":
        currentSettings.signAdminMsg = newValue;
        const showKeyStatus = newValue === 1 ? "m·ªü" : "t·∫Øt";
        await updateGroupSetting(api, message, threadId, currentSettings, `ƒê√£ ${showKeyStatus} hi·ªÉn th·ªã key qu·∫£n tr·ªã!`);
        break;

      // Th√™m c√°c case kh√°c ·ªü ƒë√¢y trong t∆∞∆°ng lai
      // case "setting_name":
      //   currentSettings.settingKey = newValue;
      //   await updateGroupSetting(...);
      //   break;

      default:
        await sendMessageStateQuote(api, message, `Lo·∫°i c√†i ƒë·∫∑t '${settingType}' kh√¥ng h·ª£p l·ªá!`, false, 60000);
        break;
    }
  } catch (error) {
    console.error("L·ªói khi thay ƒë·ªïi c√†i ƒë·∫∑t nh√≥m:", error);
    await sendMessageStateQuote(api, message, `Kh√¥ng th·ªÉ thay ƒë·ªïi c√†i ƒë·∫∑t nh√≥m: ${error.message}`, false, 60000);
  }
}

async function updateGroupSetting(api, message, threadId, settings, successMessage) {
  await api.changeGroupSetting(threadId, settings);
  await sendMessageStateQuote(api, message, successMessage, true, 60000);
}
